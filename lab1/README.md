# Лабораторная работа №1

Плохой Dockerfile должен запускаться и работать корректно, но в нём
должно быть не менее 3 “bad practices”. В хорошем они должны быть
исправлены. В Readme описать все плохие практики из кода Dockerfile и
почему они плохие, как они были исправлены в хорошем Dockerfile, а
также две плохие практики по использованию этого контейнера. Написать
два случая, когда НЕ стоит использовать контейнеры в целом
Монтирование volume в контейнере - обязательно

## Описание Dockerfile'ов

### Файл Dockerfile.bad

Этот Dockerfile намеренно содержит несколько распространённых плохих практик, но при этом рабочий. В нём представлены следующие bad practices:

#### **1. Использование `python:latest`**

Плохо, потому что тег `latest` меняется со временем. Значи сборки становятся непредсказуемыми: у разных разработчиков и CI/CD может получиться разный образ.

#### **2. Установка системных пакетов без `--no-install-recommends`**

Плохо, потому что устанавливаются ненужные зависимости из-за чего образ раздувается.

#### **3. Установка Python-зависимостей в нескольких слоях**

Плохо, потому что каждая команда `RUN` создаёт слой. А значит образ получается больше и менее кешируемый.

#### **4. Копирование всех файлов перед установкой зависимостей**

Плохо, потому что любое изменение в определённом слое Docker приводит к тому, что все следующие слои обязаны пересобраться заново, и Docker не может использовать кеш для этих слоёв, что сильно замедляет сборку.

#### **5. Запуск от root пользователя**

Плохо, потому что если кто-то получит доступ к приложению, злоумышленник получит root внутри контейнера, и во многих случаях сможет выйти наружу, а также ломает принцип least privilege.

#### **6. Shell-форма `CMD`**

Плохо, потому что сигналы не прокидываются и контейнер скорее всего некорректно завершится в Kubernetes.

### Файл Dockerfile.good

В этом файле исправлены все найденные проблемы, а сам Dockerfile соответствует современным best practices. В нём реализовано:

#### **1. Фиксированный образ `python:3.12-slim`**

Использование фиксированной версии обеспечивает повторяемость сборок и меньший размер образа.

#### **2. Установка пакетов с флагом --no-install-recommends**

Сборка командой `apt-get install -y --no-install-recommends`, а после установки очистка APT-кэша.

#### **3. Одна команда установки Python зависимостей**

Все `pip install` объединены в один слой.

#### **4. Правильный порядок слоёв**

Сначала копируется только `requirements.txt`, затем устанавливаются зависимости, и в самый последний момент файлы самого приложения.

#### **5. Запуск от непривилегированного пользователя**

Создается новый пользователь и после установки зависимостей происходит переключение на него, чтобы у контейнера было минимальное кол-во прав, если они не нужны.

#### **6. Безопасная exec-форма `CMD`**

В `Dockerfile.good` используется exec-форма: `CMD ["uvicorn", "..."]`

## Две bad practice по использованию контейнера

1. Запускать контейнер без монтирования volume для персистентных данных

   **Пример: docker run -p 8001:8001 shop-api-bad**

   Это плохо, потому что все данные, которые приложение сохраняет в /app/data при удалении контейнера или его пересоздании + по сути нарушается принцип stateless, по которому данные должны храниться вне контейнера.

2. Запуск контейнера с флагом --privileged без особой надобности

   **Пример: docker run --privileged -p 8000:8000 shop-api-bad**

   Этот флаг дает докеру практически полный доступ к системе хоста + нарушение принципа изоляции контейнера.

## Когда не стоит использовать контейнеры в целом

### **1. Приложения с высокой зависимостью от аппаратуры**

Если необходимо работать с фичами или возможностями, доступными только на хостовой ОС (например, прямой доступ к USB, RTSP-картам, специфичным интерфейсам). Контейнеры изолируют окружение и не дают гарантированного низкоуровневого доступа. В таком случае использование виртуальной машины предпочтительнее.

### **2. Когда необходимо ускорить приложение**

Docker может значительно ускорить процесс разработки, но не само приложение. Несмотря на то, что он помогает сделать приложение более масштабируемым и им смогут пользоваться больше пользователей, создание отдельного экземпляра, как правило, будет немного медленнее, чем без Docker. В большинстве случаев снижение производительности из-за Docker будет незаметно, но если задача - повысить скорость работы вашего приложения, сам Docker для этого не подходит.
